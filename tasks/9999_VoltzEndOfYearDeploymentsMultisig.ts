
import mustache from "mustache";
import "hardhat-deploy";
import { task } from "hardhat/config";
import path from "path";

// deployment and parametrisation done via a gnosis safe multisig 
// by submitting a json file generated by this script to the transaction builder

interface voltzEndOfYearTemplateDataSingular {
    token: string;
    voltzVaults: {
        marginEngine: string;
        initializeParams: VaultInitialParam;
    }[],
    vaultStrategyParams: {
        last: boolean;
        params: VaultStrategyParam;
    }[];
    strategy: string;
    erc20VaultAddress: string;
    voltzVaultAddresses: {
        last: boolean;
        address: string;
    }[];
    erc20RootVaultNFT: number;
    vaultNFTs: {
        last: boolean;
        tokenId: number;
    }[];
    vaultCap: string;
}

type voltzEndOfYearTemplateData = {
    owner: string;

    vaultRegistry: string;
    voltzVaultGovernance: string;
    erc20VaultGovernance: string;
    erc20RootVaultGovernance: string;
    masterStrategy: string;
    voltzVaultHelperSingleton: string;


    data: {
        vaultData: voltzEndOfYearTemplateDataSingular,
        last: boolean;
    }[];
};


type VaultInitialParam = {
    tickLower: number,
    tickUpper: number,
    leverageWad: string,
    marginMultiplierPostUnwindWad: string,
};

type VaultStrategyParam = {
    sigmaWad: string;
    maxPossibleLowerBoundWad: string;
    proximityWad: string;
    weight: string;
};

type VaultSetup = {
    marginEngine: string;
    vaultInitialParam: VaultInitialParam;
    vaultStrategyParam: VaultStrategyParam;
}

type NetworkSetup = { [key: string]: VaultSetup };

const setup: { [key: string]: NetworkSetup } = {
    mainnet: {
        'aUSDC_v4': { // 31 Jan 23
            marginEngine: '0x8361bcb0109eA36eE8aE18Bf513F0625F4Ac183b',
            vaultInitialParam: {
                tickLower: -2640,
                tickUpper: 3540,
                leverageWad: "50000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "300012536197026000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "75426743600639900",
                weight: "100",
            }
        },

        'cDAI_v4': { // 31 Mar 23
            marginEngine: '0x720BE99ee947292Be5d0e8Ef8D8687a7bC542f73',
            vaultInitialParam: {
                tickLower: -4080,
                tickUpper: 6900,
                leverageWad: "50000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "499999762330392000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "95785677123315700",
                weight: "85",
            }
        },

        'aDAI_v4': { // 31 Mar 23
            marginEngine: '0xBb3583EFc060eD1CFFFFC06A28f6B5381031B601',
            vaultInitialParam: {
                tickLower: -2640,
                tickUpper: 3540,
                leverageWad: "50000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "300009072791141000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "67940410361345600",
                weight: "15",
            }
        },

        'aUSDC_v5': { // 31 Mar 23
            marginEngine: '0x295891Cc72A230bcB2C2bEa3276Ac4D470495894',
            vaultInitialParam: {
                tickLower: -2640,
                tickUpper: 3540,
                leverageWad: "50000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "300012536197026000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "75426743600639900",
                weight: "100",
            }
        },

        'rETH_v2': { // 31 Mar 23
            marginEngine: '0x5E885417968b65fFAC944a2fB975C101566B4aCa',
            vaultInitialParam: {
                tickLower: -2640,
                tickUpper: 3540,
                leverageWad: "50000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "300001378599781000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "89131943783069800",
                weight: "15",
            }
        },

        'stETH_v2': { // 31 Mar 23
            marginEngine: '0x626Cf6B2fBF578653f7Fa5424962972161A79de7',
            vaultInitialParam: {
                tickLower: -2640,
                tickUpper: 3540,
                leverageWad: "50000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "300002061763262000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "65059023285524400",
                weight: "85",
            }
        },

        'borrow_aUSDT_v1': { // 31 Mar 23
            marginEngine: '0xB8A339Cd4eD2e69725d95931a18482269E006FF1',
            vaultInitialParam: {
                tickLower: -2640,
                tickUpper: 3540,
                leverageWad: "50000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "300001329882793000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "87322878356170500",
                weight: "100",
            }
        },
    }
}

async function buildVoltzEndOfYeaMultisigDeployments(
    data: voltzEndOfYearTemplateData
) {
    // Get external template with fetch
    const fs = require("fs");
    const template = fs.readFileSync(
        path.join(__dirname, "json_templates/9999_VoltzEndOfYear.json.mustache"),
        "utf8"
    );
    const output = mustache.render(template, data);

    const file = `./tasks/jsons/9999_VoltzEndOfYear.json`;
    fs.writeFileSync(file, output);
}


task("voltz-end-of-year-deployments", "Voltz End of Year Deployments")
    .setAction(
        async (_, hre) => {
            const network = hre.network.name;
            if (!(network === 'mainnet')) {
                throw new Error("This multisig setup is specific to mainnet");
            }
            const networkSetup = setup['mainnet'];

            const { deployments, getNamedAccounts } = hre;
            const { read } = deployments;
    
            const { voltzMultisig, usdc, dai, usdt, weth } =
                await getNamedAccounts();

            const getTokenPadding = (token: string): string => {
                switch (token) {
                    case usdc: {
                        return "000000";
                    }
                    case usdt: {
                        return "000000";
                    }
                    case weth: {
                        return "000000000000000000";
                    }
                    case dai: {
                        return "000000000000000000";
                    }
                    default: {
                        throw new Error("Invalid token");
                    }
                }
            }

            // Track changing states
            let nonce = Math.max(await hre.ethers.provider.getTransactionCount(voltzMultisig), 1);
            let nft = (await read("VaultRegistry", "vaultsCount")).toNumber() + 1;

            // Get the next address and increase the address
            const getNextAddress = (): string => {
                return hre.ethers.utils.getContractAddress({
                    from: voltzMultisig,
                    nonce: nonce++,
                  });
            }

            // Get the general addresses
            const voltzVaultHelper = (await hre.ethers.getContract("VoltzVaultHelper")).address;
            const voltzVaultGovernance = (await hre.ethers.getContract("VoltzVaultGovernance")).address;
            const erc20VaultGovernance = (await hre.ethers.getContract("ERC20VaultGovernance")).address;
            const erc20RootVaultGovernance = (await hre.ethers.getContract("ERC20RootVaultGovernance")).address;
            const masterStrategy = (await hre.ethers.getContract("LPOptimiserStrategy")).address;
            const vaultRegistry = (await hre.ethers.getContract("VaultRegistry")).address;

            // Set the deployment parameters

            const vaultSets: {
                voltzPools: string[];
                VAULT_CAP: number;
                token: string;
            }[] = [
                {
                    voltzPools: ['aUSDC_v4'],
                    VAULT_CAP: 250000,
                    token: usdc,
                },
                {
                    voltzPools: ['aUSDC_v5'],
                    VAULT_CAP: 250000,
                    token: usdc,
                },
                {
                    voltzPools: ['cDAI_v4', 'aDAI_v4'],
                    VAULT_CAP: 250000 * 2,
                    token: dai,
                },
                {
                    voltzPools: ['rETH_v2', 'stETH_v2'],
                    VAULT_CAP: 250 * 2,
                    token: weth,
                },
                {
                    voltzPools: ['borrow_aUSDT_v1'],
                    VAULT_CAP: 250000,
                    token: usdt,
                }
            ];

            const data: voltzEndOfYearTemplateData = {
                data: [],
                owner: voltzMultisig,
                vaultRegistry,
                voltzVaultGovernance,
                erc20VaultGovernance,
                erc20RootVaultGovernance,
                masterStrategy,
                voltzVaultHelperSingleton: voltzVaultHelper,
            };

            // Build the deployment parameters
            for (let setIndex = 0; setIndex < vaultSets.length; setIndex++) {
                const {voltzPools, VAULT_CAP, token} = vaultSets[setIndex];
                const vaultCap = (VAULT_CAP.toString()).concat(getTokenPadding(token));

                // Get the next N NFTs for Voltz vaults (each vault is represented as an nft)
                // within the vault registry, keep track of all the vaults deployed in mellow
                const voltzVaultNFTs: number[] = [];
                const voltzVaultAddresses: string[] = [];
                for (let i = 0; i < voltzPools.length; i++) {
                    voltzVaultNFTs.push(nft++);
                    voltzVaultAddresses.push(getNextAddress());
                }   

                // Get the next NFT and address for ERC20 vault
                const erc20VaultNFT = nft++;
                const erc20VaultAddress = getNextAddress();

                // Get the address of the strategy
                const strategy = getNextAddress(); // need to be set during deployment

                // Get the next NFT for ERC20 Root vault
                const erc20RootVaultNFT = nft++;

                const singularData: voltzEndOfYearTemplateDataSingular = {
                    voltzVaults: voltzPools.map(
                        (voltzVault: string) => {
                            return {
                                marginEngine: networkSetup[voltzVault].marginEngine,
                                initializeParams: networkSetup[voltzVault].vaultInitialParam
                            }
    
                        }
                    ),
                    token,
                    strategy,
                    erc20VaultAddress,
                    voltzVaultAddresses: voltzVaultAddresses.map((item, index) => {
                        return {
                            address: item,
                            last: (index + 1 === voltzVaultAddresses.length),
                        }
                    }),
                    vaultStrategyParams: voltzPools.map(
                        (item, index) => {
                            return {
                                params: networkSetup[item].vaultStrategyParam,
                                last: (index + 1 === voltzPools.length), 
                            };
                        }
                    ),
                    vaultNFTs: voltzVaultNFTs.concat([erc20VaultNFT]).map(
                        (item, index) => {
                            return {
                                tokenId: item,
                                last: (index + 1 === voltzVaultNFTs.concat([erc20VaultNFT]).length), 
                            };
                        }
                    ),
                    erc20RootVaultNFT,
                    vaultCap,
                };

                data.data.push({
                    vaultData: singularData,
                    last: (setIndex + 1 === vaultSets.length),
                });
            }
            
            await buildVoltzEndOfYeaMultisigDeployments(data);
        }
    )

