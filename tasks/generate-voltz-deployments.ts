
import mustache from "mustache";
import "hardhat-deploy";
import { task } from "hardhat/config";
import path from "path";

import { stripHexPrefix } from "ethereumjs-util";
import { IMarginEngine, IPeriphery } from "../test/types";

// deployment and parametrisation done via a gnosis safe multisig 
// by submitting a json file generated by this script to the transaction builder

type voltzTemplateDataSingular = {
    token: string;
    voltzVaults: {
        marginEngine: string;
        initializeParams: VaultInitialParam;
    }[],
    vaultStrategyParams: {
        last: boolean;
        params: VaultStrategyParam;
    }[];
    strategy: string;
    erc20VaultAddress: string;
    voltzVaultAddresses: {
        last: boolean;
        address: string;
    }[];
    erc20RootVaultNFT: number;
    vaultNFTs: {
        last: boolean;
        tokenId: number;
    }[];
    vaultCap: string;
};

type voltzTemplateData = {
    owner: string;

    vaultRegistry: string;
    voltzVaultGovernance: string;
    erc20VaultGovernance: string;
    erc20RootVaultGovernance: string;
    masterStrategy: string;
    voltzVaultHelperSingleton: string;
    rebalancer: string;

    data: {
        vaultData: voltzTemplateDataSingular,
        last: boolean;
    }[];
};

const writeVoltzDeployments = (
    data: voltzTemplateData
): void => {
    // Get external template with fetch
    const fs = require("fs");

    const template = fs.readFileSync(
        path.join(__dirname, "json_templates/VoltzDeployment.json.mustache"),
        "utf8"
    );
    const output = mustache.render(template, data);

    const jsonDir = path.join(__dirname, "jsons");
    const outFile = path.join(
        jsonDir,
        `1-VoltzDeployment.json`
    );
    if (!fs.existsSync(jsonDir)) {
        fs.mkdirSync(jsonDir);
    }
    fs.writeFileSync(outFile, output);

    console.log("Output written to ", outFile.toString());
};

type VaultInitialParam = {
    tickLower: number,
    tickUpper: number,
    leverageWad: string,
    marginMultiplierPostUnwindWad: string,
};

type VaultStrategyParam = {
    sigmaWad: string;
    maxPossibleLowerBoundWad: string;
    proximityWad: string;
    weight: string;
};

type VaultSetup = {
    marginEngine: string;
    vaultInitialParam: VaultInitialParam;
    vaultStrategyParam: VaultStrategyParam;
}

type NetworkSetup = { [key: string]: VaultSetup };

const setup: { [key: string]: NetworkSetup } = {
    mainnet: {
        // USDC
        'aUSDC': {
            marginEngine: '0x8c25c69D4999a9Bac882E4097ee1a5E2C4bd4166',
            vaultInitialParam: {
                tickLower: -11760,
                tickUpper: -9720,
                leverageWad: "150000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "300000000000000000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "75000000000000000",
                weight: "85",
            }
        },

        'borrow_aUSDC': {
            marginEngine: '0xB3d6ff11dDD6A28Cd7350d453ce502F82BA3E72c',
            vaultInitialParam: {
                tickLower: -13500,
                tickUpper: -11820,
                leverageWad: "150000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "300000000000000000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "75000000000000000",
                weight: "15",
            }
        },

        // ETH
        'stETH': {
            marginEngine: '0xdafcB84c116E7f3aF2a86d89F2F6D04Cea84deb7',
            vaultInitialParam: {
                tickLower: -17160,
                tickUpper: -15180,
                leverageWad: "150000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "500000000000000000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "100000000000000000",
                weight: "60",
            }
        },

        'rETH': {
            marginEngine: '0x9E0e377F6567f612b4cf0a86bF759ce725722139',
            vaultInitialParam: {
                tickLower: -17580,
                tickUpper: -15720,
                leverageWad: "150000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "500000000000000000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "100000000000000000",
                weight: "20",
            }
        },

        'borrow_aETH': {
            marginEngine: '0xDD974c237C1f49422ec10f7E273120FFb595c5Da',
            vaultInitialParam: {
                tickLower: -14400,
                tickUpper: -11700,
                leverageWad: "150000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "500000000000000000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "100000000000000000",
                weight: "20",
            }
        },

        // USDT
        'borrow_cUSDT': {
            marginEngine: '0xb67487b117298a47C0F774F25120b8D7428132da',
            vaultInitialParam: {
                tickLower: -15540,
                tickUpper: -13140,
                leverageWad: "150000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "500000000000000000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "100000000000000000",
                weight: "50",
            }
        },

        'borrow_aUSDT': {
            marginEngine: '0x5a3608a066e52349aFF363206faEF92414C8B9F6',
            vaultInitialParam: {
                tickLower: -14040,
                tickUpper: -11220,
                leverageWad: "150000000000000000000",
                marginMultiplierPostUnwindWad: "2000000000000000000",
            },
            vaultStrategyParam: {
                sigmaWad: "500000000000000000",
                maxPossibleLowerBoundWad: "10000000000000000000",
                proximityWad: "100000000000000000",
                weight: "50",
            }
        },
    }
}

task("generateVoltzDeployments", "Voltz Vault Deployments")
    .setAction(
        async (_, hre) => {
            const network = hre.network.name;
            if (!(network === 'mainnet')) {
                throw new Error("This multisig setup is specific to mainnet");
            }
            const networkSetup = setup['mainnet'];

            const { deployments, getNamedAccounts } = hre;
            const { read } = deployments;

            const { voltzMultisig, usdc, dai, usdt, weth, voltzPeriphery } =
                await getNamedAccounts();

            const getTokenPadding = (token: string): string => {
                switch (token) {
                    case usdc: {
                        return "000000";
                    }
                    case usdt: {
                        return "000000";
                    }
                    case weth: {
                        return "000000000000000000";
                    }
                    case dai: {
                        return "000000000000000000";
                    }
                    default: {
                        throw new Error("Invalid token");
                    }
                }
            }

            const getPredictedAddress = async (from: string, implementationContractAddress: string): Promise<string> => {
                const salt = "0x".concat(stripHexPrefix(hre.ethers.utils.hexValue(nft)).padStart(64, "0"));

                const implementation = stripHexPrefix(implementationContractAddress.toLowerCase()).padStart(40, "0");
                const initCode = `0x3d602d80600a3d3981f3363d3d373d3d3d363d73${implementation}5af43d82803e903d91602b57fd5bf3`;
                const initCodeHash = hre.ethers.utils.keccak256(initCode);

                return hre.ethers.utils.getCreate2Address(from, salt, initCodeHash);
            }

            // Get the general addresses
            const voltzVaultHelper = (await hre.ethers.getContract("VoltzVaultHelper")).address;
            const voltzVaultGovernance = (await hre.ethers.getContract("VoltzVaultGovernance")).address;
            const erc20VaultGovernance = (await hre.ethers.getContract("ERC20VaultGovernance")).address;
            const erc20RootVaultGovernance = (await hre.ethers.getContract("ERC20RootVaultGovernance")).address;
            const masterStrategy = (await hre.ethers.getContract("LPOptimiserStrategy")).address;
            const vaultRegistry = (await hre.ethers.getContract("VaultRegistry")).address;

            // Track changing states
            let masterStrategyNonce = Math.max(await hre.ethers.provider.getTransactionCount(masterStrategy), 1);
            let nft = (await read("VaultRegistry", "vaultsCount")).toNumber() + 1;

            // Set the deployment parameters

            const vaultSets: {
                voltzPools: string[];
                VAULT_CAP: number;
                token: string;
            }[] = [
                    {
                        voltzPools: ['aUSDC', 'borrow_aUSDC'],
                        VAULT_CAP: 10000000, // USDC
                        token: usdc,
                    },
                    {
                        voltzPools: ['stETH', 'rETH', 'borrow_aETH'],
                        VAULT_CAP: 6000, // ETH
                        token: weth,
                    },
                    {
                        voltzPools: ['borrow_cUSDT', 'borrow_aUSDT'],
                        VAULT_CAP: 10000000, // USDT
                        token: usdt,
                    },
                ];

            const data: voltzTemplateData = {
                data: [],
                owner: voltzMultisig,
                vaultRegistry,
                voltzVaultGovernance,
                erc20VaultGovernance,
                erc20RootVaultGovernance,
                masterStrategy,
                voltzVaultHelperSingleton: voltzVaultHelper,
                rebalancer: "0x4f8904c34bd86fd674c17fac3c5db32485aff69c",
            };

            // Perform sanity checks

            const peripheryContract = (await hre.ethers.getContractAt(
                "IPeriphery",
                voltzPeriphery
            )) as IPeriphery;

            for (const vaultSet of vaultSets) {
                let totalWeight = 0;

                for (const voltzPool of vaultSet.voltzPools) {
                    const currentTick = await peripheryContract.getCurrentTick(networkSetup[voltzPool].marginEngine);
                    const { tickLower, tickUpper } = networkSetup[voltzPool].vaultInitialParam;

                    if (!(tickLower <= currentTick && currentTick <= tickUpper)) {
                        throw new Error(`${voltzPool} out of range. Range [${tickLower}, ${tickUpper}] but current tick ${currentTick}`);
                    }

                    const marginEngineContract = (await hre.ethers.getContractAt(
                        "IMarginEngine",
                        networkSetup[voltzPool].marginEngine
                    )) as IMarginEngine;

                    const termEndTimestampWad = await marginEngineContract.termEndTimestampWad();

                    const durationInMS =
                        Number(hre.ethers.utils.formatUnits(termEndTimestampWad, 15)) -
                        Date.now().valueOf();
                    const durationInDays = Math.floor(durationInMS / 24 / 60 / 60 / 1000);
                    if (durationInDays < 20) {
                        throw new Error(`${voltzPool} is less than 20-day long, it matures in ${durationInDays} days`);
                    }

                    totalWeight += Number(networkSetup[voltzPool].vaultStrategyParam.weight);
                }

                if (!(totalWeight === 100)) {
                    throw new Error(`Total weight is not 100 (it's actually ${totalWeight})`);
                }
            }


            // Build the deployment parameters
            for (let setIndex = 0; setIndex < vaultSets.length; setIndex++) {
                const { voltzPools, VAULT_CAP, token } = vaultSets[setIndex];
                const vaultCap = (VAULT_CAP.toString()).concat(getTokenPadding(token));

                // Get the next N NFTs for Voltz vaults (each vault is represented as an nft)
                // within the vault registry, keep track of all the vaults deployed in mellow
                const voltzVaultNFTs: number[] = [];
                const voltzVaultAddresses: string[] = [];
                for (let i = 0; i < voltzPools.length; i++) {
                    voltzVaultNFTs.push(nft);

                    const predictedVoltzVaultAddress = await getPredictedAddress(voltzVaultGovernance, (await hre.ethers.getContract("VoltzVault")).address);

                    nft++;
                    voltzVaultAddresses.push(predictedVoltzVaultAddress);
                }

                // Get the next NFT and address for ERC20 vault
                const erc20VaultNFT = nft;
                const erc20VaultAddress = await getPredictedAddress(erc20VaultGovernance, (await hre.ethers.getContract("ERC20Vault")).address);
                nft++;

                // Get the address of the strategy
                const strategy = hre.ethers.utils.getContractAddress({
                    from: masterStrategy,
                    nonce: masterStrategyNonce++,
                });

                // Get the next NFT for ERC20 Root vault
                const erc20RootVaultNFT = nft;
                nft++;

                const singularData: voltzTemplateDataSingular = {
                    voltzVaults: voltzPools.map(
                        (voltzVault: string) => {
                            return {
                                marginEngine: networkSetup[voltzVault].marginEngine,
                                initializeParams: networkSetup[voltzVault].vaultInitialParam
                            }

                        }
                    ),
                    token,
                    strategy,
                    erc20VaultAddress,
                    voltzVaultAddresses: voltzVaultAddresses.map((item, index) => {
                        return {
                            address: item,
                            last: (index + 1 === voltzVaultAddresses.length),
                        }
                    }),
                    vaultStrategyParams: voltzPools.map(
                        (item, index) => {
                            return {
                                params: networkSetup[item].vaultStrategyParam,
                                last: (index + 1 === voltzPools.length),
                            };
                        }
                    ),
                    vaultNFTs: [erc20VaultNFT].concat(voltzVaultNFTs).map(
                        (item, index) => {
                            return {
                                tokenId: item,
                                last: (index + 1 === [erc20VaultNFT].concat(voltzVaultNFTs).length),
                            };
                        }
                    ),
                    erc20RootVaultNFT,
                    vaultCap,
                };

                data.data.push({
                    vaultData: singularData,
                    last: (setIndex + 1 === vaultSets.length),
                });
            }

            writeVoltzDeployments(data);
        }
    )

