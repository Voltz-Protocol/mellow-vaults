
import mustache from "mustache";
import "hardhat-deploy";
import { task } from "hardhat/config";
import path from "path";

// rebalances done via a gnosis safe multisig 
// by submitting a json file generated by this script to the transaction builder

interface RebalanceTemplateData {
    vaults: {
        strategy: string;
        index: number;
        changedParams: {
            sigmaWad: string;
            maxPossibleLowerBoundWad: string;
            proximityWad: string;
            weight: string;
        };
        fixedRateWad: string;
        sameParams: {
            sigmaWad: string;
            maxPossibleLowerBoundWad: string;
            proximityWad: string;
            weight: string;
        };
        last: boolean;
    }[];
};

async function buildVoltzEndOfYeaMultisigDeployments(
    data: RebalanceTemplateData
) {
    // Get external template with fetch
    const fs = require("fs");
    const template = fs.readFileSync(
        path.join(__dirname, "json_templates/Rebalance.json.mustache"),
        "utf8"
    );
    const output = mustache.render(template, data);

    const file = `./tasks/jsons/Rebalance.json`;
    fs.writeFileSync(file, output);
}

task("trigger-rebalances", "Manual rebalances")
    .setAction(
        async (_, hre) => {
            const network = hre.network.name;
            if (!(network === 'mainnet')) {
                throw new Error("This multisig setup is specific to mainnet");
            }

            const strategies = [
                "0x519746e55e77c53184b7bbdb3a41150737c32caf",
                "0x23fd15572f221c8fec40ef1d1ed027c8bcc6e4cb",
                "0x523ee1651f47604f846221dec328080c9843b24f",
                "0x816aa4324967ea571927e8f04e976f509c631f78",
                "0xa8811f93b1e604e0d98b22b38aa04917d36b66d0",
            ];

            const peripheryContract = await hre.ethers.getContract("Periphery"); 

            const data: RebalanceTemplateData = {vaults: []};

            for (const strategy of strategies) {
                const strategyContract = await hre.ethers.getContractAt("LPOptimiserStrategy", strategy); 

                const vaults = await strategyContract.getVaults();
                for (let i = 0; i < vaults.length; i++) {
                    const vault = vaults[i];
                    const vaultContract = await hre.ethers.getContractAt("VoltzVault", vault); 
                    const vaultParams = await strategyContract.getVaultParams(i);
                    
                    const marginEngine = await vaultContract.marginEngine();
                    const tick = await peripheryContract.getCurrentTick(marginEngine);

                    const currentFixedRateWad = await strategyContract.convertTickToFixedRate(tick);

                    data.vaults.push({
                        strategy,
                        index: i,
                        changedParams: {
                            sigmaWad: vaultParams.sigmaWad,
                            maxPossibleLowerBoundWad: vaultParams.maxPossibleLowerBoundWad,
                            proximityWad: vaultParams.sigmaWad,
                            weight: vaultParams.weight,
                        },
                        sameParams: {
                            sigmaWad: vaultParams.sigmaWad,
                            maxPossibleLowerBoundWad: vaultParams.maxPossibleLowerBoundWad,
                            proximityWad: vaultParams.proximityWad,
                            weight: vaultParams.weight,
                        },
                        fixedRateWad: currentFixedRateWad,
                        last: false,
                    });
                }   
            }

            data.vaults[data.vaults.length - 1].last = true;

            await buildVoltzEndOfYeaMultisigDeployments(data);
        }
    )

