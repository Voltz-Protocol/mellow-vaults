{
  "address": "0x3C4761f50ebE47269701Bc04517F8ab39F195A42",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "tvls",
          "type": "uint256[]"
        },
        {
          "internalType": "address[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "contract IOracle",
          "name": "oracle",
          "type": "address"
        }
      ],
      "name": "getTvlToken0",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "tvl0",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x5f72de1ae5aadd21983f66f915da0b16415307c2443e3119db9fd203dbe79650",
  "receipt": {
    "to": null,
    "from": "0x5f198d6F84C3b8E9CA12530ebbA54C3dB53e847D",
    "contractAddress": "0x3C4761f50ebE47269701Bc04517F8ab39F195A42",
    "transactionIndex": 14,
    "gasUsed": "396563",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x6cff6a253d2c50566fac0dcfbf9f0ff56d722c3c0d4eabf341b0fba15850e1b9",
    "transactionHash": "0x5f72de1ae5aadd21983f66f915da0b16415307c2443e3119db9fd203dbe79650",
    "logs": [],
    "blockNumber": 7850726,
    "cumulativeGasUsed": "1402303",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "1984535d51a55304aed3f058b4264cb9",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tvls\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"getTvlToken0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tvl0\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/utils/ERC20RootVaultHelper.sol\":\"ERC20RootVaultHelper\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/oracles/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.9;\\r\\n\\r\\ninterface IOracle {\\r\\n    /// @notice Oracle price for tokens as a Q64.96 value.\\r\\n    /// @notice Returns pricing information based on the indexes of non-zero bits in safetyIndicesSet.\\r\\n    /// @notice It is possible that not all indices will have their respective prices returned.\\r\\n    /// @dev The price is token1 / token0 i.e. how many weis of token1 required for 1 wei of token0.\\r\\n    /// The safety indexes are:\\r\\n    ///\\r\\n    /// 1 - unsafe, this is typically a spot price that can be easily manipulated,\\r\\n    ///\\r\\n    /// 2 - 4 - more or less safe, this is typically a uniV3 oracle, where the safety is defined by the timespan of the average price\\r\\n    ///\\r\\n    /// 5 - safe - this is typically a chailink oracle\\r\\n    /// @param token0 Reference to token0\\r\\n    /// @param token1 Reference to token1\\r\\n    /// @param safetyIndicesSet Bitmask of safety indices that are allowed for the return prices. For set of safety indexes = { 1 }, safetyIndicesSet = 0x2\\r\\n    /// @return pricesX96 Prices that satisfy safetyIndex and tokens\\r\\n    /// @return safetyIndices Safety indices for those prices\\r\\n    function priceX96(\\r\\n        address token0,\\r\\n        address token1,\\r\\n        uint256 safetyIndicesSet\\r\\n    ) external view returns (uint256[] memory pricesX96, uint256[] memory safetyIndices);\\r\\n}\\r\\n\",\"keccak256\":\"0x4629a653a356248a9683d6e02a6fb738802b60086b1cb8cdbfa05385f1914b5e\",\"license\":\"MIT\"},\"contracts/interfaces/utils/IERC20RootVaultHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nimport \\\"../oracles/IOracle.sol\\\";\\r\\n\\r\\ninterface IERC20RootVaultHelper {\\r\\n    function getTvlToken0(\\r\\n        uint256[] calldata tvls,\\r\\n        address[] calldata tokens,\\r\\n        IOracle oracle\\r\\n    ) external view returns (uint256 tvl0);\\r\\n}\\r\\n\",\"keccak256\":\"0x2b3943703b9d7a07ece1cb6baf4d3286628ba8bf2dd3ddb8716e037cd4af7e09\",\"license\":\"MIT\"},\"contracts/libraries/CommonLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nimport \\\"./external/FullMath.sol\\\";\\r\\nimport \\\"./ExceptionsLibrary.sol\\\";\\r\\n\\r\\n/// @notice CommonLibrary shared utilities\\r\\nlibrary CommonLibrary {\\r\\n    uint256 constant DENOMINATOR = 10**9;\\r\\n    uint256 constant D18 = 10**18;\\r\\n    uint256 constant YEAR = 365 * 24 * 3600;\\r\\n    uint256 constant Q128 = 2**128;\\r\\n    uint256 constant Q96 = 2**96;\\r\\n    uint256 constant Q48 = 2**48;\\r\\n    uint256 constant Q160 = 2**160;\\r\\n    uint256 constant UNI_FEE_DENOMINATOR = 10**6;\\r\\n\\r\\n    /// @notice Sort uint256 using bubble sort. The sorting is done in-place.\\r\\n    /// @param arr Array of uint256\\r\\n    function sortUint(uint256[] memory arr) internal pure {\\r\\n        uint256 l = arr.length;\\r\\n        for (uint256 i = 0; i < l; ++i) {\\r\\n            for (uint256 j = i + 1; j < l; ++j) {\\r\\n                if (arr[i] > arr[j]) {\\r\\n                    uint256 temp = arr[i];\\r\\n                    arr[i] = arr[j];\\r\\n                    arr[j] = temp;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Checks if array of addresses is sorted and all adresses are unique\\r\\n    /// @param tokens A set of addresses to check\\r\\n    /// @return `true` if all addresses are sorted and unique, `false` otherwise\\r\\n    function isSortedAndUnique(address[] memory tokens) internal pure returns (bool) {\\r\\n        if (tokens.length < 2) {\\r\\n            return true;\\r\\n        }\\r\\n        for (uint256 i = 0; i < tokens.length - 1; ++i) {\\r\\n            if (tokens[i] >= tokens[i + 1]) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Projects tokenAmounts onto subset or superset of tokens\\r\\n    /// @dev\\r\\n    /// Requires both sets of tokens to be sorted. When tokens are not sorted, it's undefined behavior.\\r\\n    /// If there is a token in tokensToProject that is not part of tokens and corresponding tokenAmountsToProject > 0, reverts.\\r\\n    /// Zero token amount is eqiuvalent to missing token\\r\\n    function projectTokenAmounts(\\r\\n        address[] memory tokens,\\r\\n        address[] memory tokensToProject,\\r\\n        uint256[] memory tokenAmountsToProject\\r\\n    ) internal pure returns (uint256[] memory) {\\r\\n        uint256[] memory res = new uint256[](tokens.length);\\r\\n        uint256 t = 0;\\r\\n        uint256 tp = 0;\\r\\n        while ((t < tokens.length) && (tp < tokensToProject.length)) {\\r\\n            if (tokens[t] < tokensToProject[tp]) {\\r\\n                res[t] = 0;\\r\\n                t++;\\r\\n            } else if (tokens[t] > tokensToProject[tp]) {\\r\\n                if (tokenAmountsToProject[tp] == 0) {\\r\\n                    tp++;\\r\\n                } else {\\r\\n                    revert(\\\"TPS\\\");\\r\\n                }\\r\\n            } else {\\r\\n                res[t] = tokenAmountsToProject[tp];\\r\\n                t++;\\r\\n                tp++;\\r\\n            }\\r\\n        }\\r\\n        while (t < tokens.length) {\\r\\n            res[t] = 0;\\r\\n            t++;\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    /// @notice Calculated sqrt of uint in X96 format\\r\\n    /// @param xX96 input number in X96 format\\r\\n    /// @return sqrt of xX96 in X96 format\\r\\n    function sqrtX96(uint256 xX96) internal pure returns (uint256) {\\r\\n        uint256 sqX96 = sqrt(xX96);\\r\\n        return sqX96 << 48;\\r\\n    }\\r\\n\\r\\n    /// @notice Calculated sqrt of uint\\r\\n    /// @param x input number\\r\\n    /// @return sqrt of x\\r\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\r\\n        if (x == 0) return 0;\\r\\n        uint256 xx = x;\\r\\n        uint256 r = 1;\\r\\n        if (xx >= 0x100000000000000000000000000000000) {\\r\\n            xx >>= 128;\\r\\n            r <<= 64;\\r\\n        }\\r\\n        if (xx >= 0x10000000000000000) {\\r\\n            xx >>= 64;\\r\\n            r <<= 32;\\r\\n        }\\r\\n        if (xx >= 0x100000000) {\\r\\n            xx >>= 32;\\r\\n            r <<= 16;\\r\\n        }\\r\\n        if (xx >= 0x10000) {\\r\\n            xx >>= 16;\\r\\n            r <<= 8;\\r\\n        }\\r\\n        if (xx >= 0x100) {\\r\\n            xx >>= 8;\\r\\n            r <<= 4;\\r\\n        }\\r\\n        if (xx >= 0x10) {\\r\\n            xx >>= 4;\\r\\n            r <<= 2;\\r\\n        }\\r\\n        if (xx >= 0x8) {\\r\\n            r <<= 1;\\r\\n        }\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        uint256 r1 = x / r;\\r\\n        return (r < r1 ? r : r1);\\r\\n    }\\r\\n\\r\\n    /// @notice Recovers signer address from signed message hash\\r\\n    /// @param _ethSignedMessageHash signed message\\r\\n    /// @param _signature contatenated ECDSA r, s, v (65 bytes)\\r\\n    /// @return Recovered address if the signature is valid, address(0) otherwise\\r\\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {\\r\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\r\\n\\r\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\r\\n    }\\r\\n\\r\\n    /// @notice Get ECDSA r, s, v from signature\\r\\n    /// @param sig signature (65 bytes)\\r\\n    /// @return r ECDSA r\\r\\n    /// @return s ECDSA s\\r\\n    /// @return v ECDSA v\\r\\n    function splitSignature(bytes memory sig)\\r\\n        internal\\r\\n        pure\\r\\n        returns (\\r\\n            bytes32 r,\\r\\n            bytes32 s,\\r\\n            uint8 v\\r\\n        )\\r\\n    {\\r\\n        require(sig.length == 65, ExceptionsLibrary.INVALID_LENGTH);\\r\\n\\r\\n        assembly {\\r\\n            r := mload(add(sig, 32))\\r\\n            s := mload(add(sig, 64))\\r\\n            v := byte(0, mload(add(sig, 96)))\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x7d34a904dda4bf094ea37d2f7aeaac1b2487f450e9df2d39e1027ef97b6b071c\",\"license\":\"MIT\"},\"contracts/libraries/ExceptionsLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.9;\\r\\n\\r\\n/// @notice Exceptions stores project`s smart-contracts exceptions\\r\\nlibrary ExceptionsLibrary {\\r\\n    string constant ADDRESS_ZERO = \\\"AZ\\\";\\r\\n    string constant VALUE_ZERO = \\\"VZ\\\";\\r\\n    string constant EMPTY_LIST = \\\"EMPL\\\";\\r\\n    string constant NOT_FOUND = \\\"NF\\\";\\r\\n    string constant INIT = \\\"INIT\\\";\\r\\n    string constant DUPLICATE = \\\"DUP\\\";\\r\\n    string constant NULL = \\\"NULL\\\";\\r\\n    string constant TIMESTAMP = \\\"TS\\\";\\r\\n    string constant FORBIDDEN = \\\"FRB\\\";\\r\\n    string constant ALLOWLIST = \\\"ALL\\\";\\r\\n    string constant LIMIT_OVERFLOW = \\\"LIMO\\\";\\r\\n    string constant LIMIT_UNDERFLOW = \\\"LIMU\\\";\\r\\n    string constant INVALID_VALUE = \\\"INV\\\";\\r\\n    string constant INVARIANT = \\\"INVA\\\";\\r\\n    string constant INVALID_TARGET = \\\"INVTR\\\";\\r\\n    string constant INVALID_TOKEN = \\\"INVTO\\\";\\r\\n    string constant INVALID_INTERFACE = \\\"INVI\\\";\\r\\n    string constant INVALID_SELECTOR = \\\"INVS\\\";\\r\\n    string constant INVALID_STATE = \\\"INVST\\\";\\r\\n    string constant INVALID_LENGTH = \\\"INVL\\\";\\r\\n    string constant LOCK = \\\"LCKD\\\";\\r\\n    string constant DISABLED = \\\"DIS\\\";\\r\\n    string constant REBALANCE_NOT_NEEDED = \\\"RNN\\\";\\r\\n}\\r\\n\",\"keccak256\":\"0x3aa0aa636063dcdbf6742b1b0b51ae15df3ba0f225c5c4178ee23e91bfc15060\",\"license\":\"MIT\"},\"contracts/libraries/external/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.8.9;\\r\\n\\r\\n/// @title Contains 512-bit math functions\\r\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\r\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\r\\nlibrary FullMath {\\r\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n    /// @param a The multiplicand\\r\\n    /// @param b The multiplier\\r\\n    /// @param denominator The divisor\\r\\n    /// @return result The 256-bit result\\r\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\r\\n    function mulDiv(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        // diff: original lib works under 0.7.6 with overflows enabled\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = a * b\\r\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\r\\n            // then use the Chinese Remainder Theorem to reconstruct\\r\\n            // the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2**256 + prod0\\r\\n            uint256 prod0; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(a, b, not(0))\\r\\n                prod0 := mul(a, b)\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division\\r\\n            if (prod1 == 0) {\\r\\n                require(denominator > 0);\\r\\n                assembly {\\r\\n                    result := div(prod0, denominator)\\r\\n                }\\r\\n                return result;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2**256.\\r\\n            // Also prevents denominator == 0\\r\\n            require(denominator > prod1);\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\r\\n            // Compute remainder using mulmod\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                remainder := mulmod(a, b, denominator)\\r\\n            }\\r\\n            // Subtract 256 bit number from 512 bit number\\r\\n            assembly {\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator\\r\\n            // Compute largest power of two divisor of denominator.\\r\\n            // Always >= 1.\\r\\n            // diff: original uint256 twos = -denominator & denominator;\\r\\n            uint256 twos = uint256(-int256(denominator)) & denominator;\\r\\n            // Divide denominator by power of two\\r\\n            assembly {\\r\\n                denominator := div(denominator, twos)\\r\\n            }\\r\\n\\r\\n            // Divide [prod1 prod0] by the factors of two\\r\\n            assembly {\\r\\n                prod0 := div(prod0, twos)\\r\\n            }\\r\\n            // Shift in bits from prod1 into prod0. For this we need\\r\\n            // to flip `twos` such that it is 2**256 / twos.\\r\\n            // If twos is zero, then it becomes one\\r\\n            assembly {\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2**256\\r\\n            // Now that denominator is an odd number, it has an inverse\\r\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\r\\n            // Compute the inverse by starting with a seed that is correct\\r\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\r\\n            uint256 inv = (3 * denominator) ^ 2;\\r\\n            // Now use Newton-Raphson iteration to improve the precision.\\r\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\r\\n            // arithmetic, doubling the correct bits in each step.\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\r\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying\\r\\n            // with the modular inverse of denominator. This will give us the\\r\\n            // correct result modulo 2**256. Since the precoditions guarantee\\r\\n            // that the outcome is less than 2**256, this is the final result.\\r\\n            // We don't need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inv;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n    /// @param a The multiplicand\\r\\n    /// @param b The multiplier\\r\\n    /// @param denominator The divisor\\r\\n    /// @return result The 256-bit result\\r\\n    function mulDivRoundingUp(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        // diff: original lib works under 0.7.6 with overflows enabled\\r\\n        unchecked {\\r\\n            result = mulDiv(a, b, denominator);\\r\\n            if (mulmod(a, b, denominator) > 0) {\\r\\n                require(result < type(uint256).max);\\r\\n                result++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function mulDivSigned(\\r\\n        int256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (int256 result) {\\r\\n        if (a < 0) return -int256(mulDiv(uint256(-a), b, denominator));\\r\\n        return int256(mulDiv(uint256(a), b, denominator));\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x57f9ed1224e68ed9e057313f83a5ccbb5ceb309f0a01b8fbc45ebc167f5f5dcb\",\"license\":\"MIT\"},\"contracts/utils/ERC20RootVaultHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity 0.8.9;\\r\\nimport \\\"../libraries/ExceptionsLibrary.sol\\\";\\r\\nimport \\\"../interfaces/utils/IERC20RootVaultHelper.sol\\\";\\r\\nimport \\\"../libraries/CommonLibrary.sol\\\";\\r\\nimport \\\"../libraries/external/FullMath.sol\\\";\\r\\n\\r\\ncontract ERC20RootVaultHelper is IERC20RootVaultHelper {\\r\\n    function getTvlToken0(\\r\\n        uint256[] calldata tvls,\\r\\n        address[] calldata tokens,\\r\\n        IOracle oracle\\r\\n    ) external view returns (uint256 tvl0) {\\r\\n        tvl0 = tvls[0];\\r\\n        for (uint256 i = 1; i < tvls.length; i++) {\\r\\n            (uint256[] memory pricesX96, ) = oracle.priceX96(tokens[0], tokens[i], 0x30);\\r\\n            require(pricesX96.length > 0, ExceptionsLibrary.VALUE_ZERO);\\r\\n            uint256 priceX96 = 0;\\r\\n            for (uint256 j = 0; j < pricesX96.length; j++) {\\r\\n                priceX96 += pricesX96[j];\\r\\n            }\\r\\n            priceX96 /= pricesX96.length;\\r\\n            tvl0 += FullMath.mulDiv(tvls[i], CommonLibrary.Q96, priceX96);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xe4ea958d88d20a9b2e88ca24269cdf1d6c3404c572c6748476343520d1e414d1\",\"license\":\"GPL-2.0-or-later\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610637806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80634bd8911414610030575b600080fd5b61004361003e366004610375565b610055565b60405190815260200160405180910390f35b60008585600081811061006a5761006a6103f9565b9050602002013590506000600190505b85811015610253576000836001600160a01b0316636d80125b878760008181106100a6576100a66103f9565b90506020020160208101906100bb919061040f565b8888868181106100cd576100cd6103f9565b90506020020160208101906100e2919061040f565b6040516001600160e01b031960e085901b1681526001600160a01b039283166004820152911660248201526030604482015260640160006040518083038186803b15801561012f57600080fd5b505afa158015610143573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261016b91908101906104dd565b5090506000815111604051806040016040528060028152602001612b2d60f11b815250906101b55760405162461bcd60e51b81526004016101ac9190610541565b60405180910390fd5b506000805b82518110156101fc578281815181106101d5576101d56103f9565b6020026020010151826101e891906105ac565b9150806101f4816105c4565b9150506101ba565b50815161020990826105df565b9050610232898985818110610220576102206103f9565b90506020020135600160601b8361025d565b61023c90856105ac565b93505050808061024b906105c4565b91505061007a565b5095945050505050565b600080806000198587098587029250828110838203039150508060001415610297576000841161028c57600080fd5b50829004905061030a565b8084116102a357600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150505b9392505050565b60008083601f84011261032357600080fd5b50813567ffffffffffffffff81111561033b57600080fd5b6020830191508360208260051b850101111561035657600080fd5b9250929050565b6001600160a01b038116811461037257600080fd5b50565b60008060008060006060868803121561038d57600080fd5b853567ffffffffffffffff808211156103a557600080fd5b6103b189838a01610311565b909750955060208801359150808211156103ca57600080fd5b506103d788828901610311565b90945092505060408601356103eb8161035d565b809150509295509295909350565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561042157600080fd5b813561030a8161035d565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261045357600080fd5b8151602067ffffffffffffffff808311156104705761047061042c565b8260051b604051601f19603f830116810181811084821117156104955761049561042c565b6040529384528581018301938381019250878511156104b357600080fd5b83870191505b848210156104d2578151835291830191908301906104b9565b979650505050505050565b600080604083850312156104f057600080fd5b825167ffffffffffffffff8082111561050857600080fd5b61051486838701610442565b9350602085015191508082111561052a57600080fd5b5061053785828601610442565b9150509250929050565b600060208083528351808285015260005b8181101561056e57858101830151858201604001528201610552565b81811115610580576000604083870101525b50601f01601f1916929092016040019392505050565b634e487b7160e01b600052601160045260246000fd5b600082198211156105bf576105bf610596565b500190565b60006000198214156105d8576105d8610596565b5060010190565b6000826105fc57634e487b7160e01b600052601260045260246000fd5b50049056fea264697066735822122072e07c2407f0ee148ad20c049cdf9cd0c6a5d5df585a16fb550b7d8937afc55564736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80634bd8911414610030575b600080fd5b61004361003e366004610375565b610055565b60405190815260200160405180910390f35b60008585600081811061006a5761006a6103f9565b9050602002013590506000600190505b85811015610253576000836001600160a01b0316636d80125b878760008181106100a6576100a66103f9565b90506020020160208101906100bb919061040f565b8888868181106100cd576100cd6103f9565b90506020020160208101906100e2919061040f565b6040516001600160e01b031960e085901b1681526001600160a01b039283166004820152911660248201526030604482015260640160006040518083038186803b15801561012f57600080fd5b505afa158015610143573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261016b91908101906104dd565b5090506000815111604051806040016040528060028152602001612b2d60f11b815250906101b55760405162461bcd60e51b81526004016101ac9190610541565b60405180910390fd5b506000805b82518110156101fc578281815181106101d5576101d56103f9565b6020026020010151826101e891906105ac565b9150806101f4816105c4565b9150506101ba565b50815161020990826105df565b9050610232898985818110610220576102206103f9565b90506020020135600160601b8361025d565b61023c90856105ac565b93505050808061024b906105c4565b91505061007a565b5095945050505050565b600080806000198587098587029250828110838203039150508060001415610297576000841161028c57600080fd5b50829004905061030a565b8084116102a357600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150505b9392505050565b60008083601f84011261032357600080fd5b50813567ffffffffffffffff81111561033b57600080fd5b6020830191508360208260051b850101111561035657600080fd5b9250929050565b6001600160a01b038116811461037257600080fd5b50565b60008060008060006060868803121561038d57600080fd5b853567ffffffffffffffff808211156103a557600080fd5b6103b189838a01610311565b909750955060208801359150808211156103ca57600080fd5b506103d788828901610311565b90945092505060408601356103eb8161035d565b809150509295509295909350565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561042157600080fd5b813561030a8161035d565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261045357600080fd5b8151602067ffffffffffffffff808311156104705761047061042c565b8260051b604051601f19603f830116810181811084821117156104955761049561042c565b6040529384528581018301938381019250878511156104b357600080fd5b83870191505b848210156104d2578151835291830191908301906104b9565b979650505050505050565b600080604083850312156104f057600080fd5b825167ffffffffffffffff8082111561050857600080fd5b61051486838701610442565b9350602085015191508082111561052a57600080fd5b5061053785828601610442565b9150509250929050565b600060208083528351808285015260005b8181101561056e57858101830151858201604001528201610552565b81811115610580576000604083870101525b50601f01601f1916929092016040019392505050565b634e487b7160e01b600052601160045260246000fd5b600082198211156105bf576105bf610596565b500190565b60006000198214156105d8576105d8610596565b5060010190565b6000826105fc57634e487b7160e01b600052601260045260246000fd5b50049056fea264697066735822122072e07c2407f0ee148ad20c049cdf9cd0c6a5d5df585a16fb550b7d8937afc55564736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}