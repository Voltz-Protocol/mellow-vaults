{
  "address": "0x78674E6883A1B2cCcd41AFd451897ca01429c151",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IUniswapV2Factory",
          "name": "factory_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "contractName",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "contractNameBytes",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "contractVersion",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "contractVersionBytes",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "factory",
      "outputs": [
        {
          "internalType": "contract IUniswapV2Factory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token0",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "token1",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "safetyIndicesSet",
          "type": "uint256"
        }
      ],
      "name": "priceX96",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "pricesX96",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "safetyIndices",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "safetyIndex",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x5d9a7fd76921e5069ca337538c8b2a0b545822d7befe5258c746596cdad7aa94",
  "receipt": {
    "to": null,
    "from": "0xF13c450e913001Ac0647710D44d8eE9760009b4D",
    "contractAddress": "0x78674E6883A1B2cCcd41AFd451897ca01429c151",
    "transactionIndex": 27,
    "gasUsed": "478567",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xeb3b15efe6fe978fc05196832deb9fe63a851cd5f97272da9d07cd7f68def497",
    "transactionHash": "0x5d9a7fd76921e5069ca337538c8b2a0b545822d7befe5258c746596cdad7aa94",
    "logs": [],
    "blockNumber": 15237742,
    "cumulativeGasUsed": "2458341",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f"
  ],
  "solcInputHash": "1d49726b754ac7f6cccc3c78633d62a4",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"factory_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"contractName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractNameBytes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractVersionBytes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safetyIndicesSet\",\"type\":\"uint256\"}],\"name\":\"priceX96\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pricesX96\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"safetyIndices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safetyIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"priceX96(address,address,uint256)\":{\"details\":\"The price is token1 / token0 i.e. how many weis of token1 required for 1 wei of token0. The safety indexes are: 1 - unsafe, this is typically a spot price that can be easily manipulated, 2 - 4 - more or less safe, this is typically a uniV3 oracle, where the safety is defined by the timespan of the average price 5 - safe - this is typically a chailink oracle\",\"params\":{\"safetyIndicesSet\":\"Bitmask of safety indices that are allowed for the return prices. For set of safety indexes = { 1 }, safetyIndicesSet = 0x2\",\"token0\":\"Reference to token0\",\"token1\":\"Reference to token1\"},\"returns\":{\"pricesX96\":\"Prices that satisfy safetyIndex and tokens\",\"safetyIndices\":\"Safety indices for those prices\"}},\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"factory()\":{\"notice\":\"Reference to UniV2 factory\"},\"priceX96(address,address,uint256)\":{\"notice\":\"Oracle price for tokens as a Q64.96 value.Returns pricing information based on the indexes of non-zero bits in safetyIndicesSet.It is possible that not all indices will have their respective prices returned.\"},\"safetyIndex()\":{\"notice\":\"Index of safety bit\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/oracles/UniV2Oracle.sol\":\"UniV2Oracle\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x905cd0ecd91d1de79a4679d745b79cf852ca8ccda5d25d1c49c6bd17a5edc0cf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x6aa521718bf139b44ce56f194f6aea1d590cacef995b5a84703fb1579fa49be9\",\"license\":\"MIT\"},\"contracts/interfaces/external/univ2/IUniswapV2Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IUniswapV2Factory {\\n    function getPair(address token0, address token1) external view returns (address);\\n}\\n\",\"keccak256\":\"0x05f1a28c4a643ca0c9f28a696052e35da0b809df03f54356cdc75dc6fa49b2a9\",\"license\":\"MIT\"},\"contracts/interfaces/external/univ2/IUniswapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IUniswapV2Pair {\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x61fd7ab6aed2cabd33dd8946b6fe4ea23b624c644e114880d50e8e915ec8c383\",\"license\":\"MIT\"},\"contracts/interfaces/oracles/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IOracle {\\n    /// @notice Oracle price for tokens as a Q64.96 value.\\n    /// @notice Returns pricing information based on the indexes of non-zero bits in safetyIndicesSet.\\n    /// @notice It is possible that not all indices will have their respective prices returned.\\n    /// @dev The price is token1 / token0 i.e. how many weis of token1 required for 1 wei of token0.\\n    /// The safety indexes are:\\n    ///\\n    /// 1 - unsafe, this is typically a spot price that can be easily manipulated,\\n    ///\\n    /// 2 - 4 - more or less safe, this is typically a uniV3 oracle, where the safety is defined by the timespan of the average price\\n    ///\\n    /// 5 - safe - this is typically a chailink oracle\\n    /// @param token0 Reference to token0\\n    /// @param token1 Reference to token1\\n    /// @param safetyIndicesSet Bitmask of safety indices that are allowed for the return prices. For set of safety indexes = { 1 }, safetyIndicesSet = 0x2\\n    /// @return pricesX96 Prices that satisfy safetyIndex and tokens\\n    /// @return safetyIndices Safety indices for those prices\\n    function priceX96(\\n        address token0,\\n        address token1,\\n        uint256 safetyIndicesSet\\n    ) external view returns (uint256[] memory pricesX96, uint256[] memory safetyIndices);\\n}\\n\",\"keccak256\":\"0x64a04c20495bc7e46040acb0df28c866cfd2d4fd8eced03bc3595d817619dc19\",\"license\":\"MIT\"},\"contracts/interfaces/oracles/IUniV2Oracle.sol\":{\"content\":\"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.9;\\n\\nimport \\\"../external/univ2/IUniswapV2Factory.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n\\ninterface IUniV2Oracle is IOracle {\\n    /// @notice Reference to UniV2 factory\\n    function factory() external returns (IUniswapV2Factory);\\n\\n    /// @notice Index of safety bit\\n    function safetyIndex() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x5ec3785d1c3eaba4c3b819b97a5869dd2aa0beca1593f06e5a3c16b0ba753df2\",\"license\":\"BSL-1.1\"},\"contracts/interfaces/utils/IContractMeta.sol\":{\"content\":\"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.9;\\n\\ninterface IContractMeta {\\n    function contractName() external view returns (string memory);\\n    function contractNameBytes() external view returns (bytes32);\\n\\n    function contractVersion() external view returns (string memory);\\n    function contractVersionBytes() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xab6c1427012bddbeae91599f859668df829c133b73b77572cf60c2bbc369f6da\",\"license\":\"BSL-1.1\"},\"contracts/libraries/CommonLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./external/FullMath.sol\\\";\\nimport \\\"./ExceptionsLibrary.sol\\\";\\n\\n/// @notice CommonLibrary shared utilities\\nlibrary CommonLibrary {\\n    uint256 constant DENOMINATOR = 10**9;\\n    uint256 constant D18 = 10**18;\\n    uint256 constant YEAR = 365 * 24 * 3600;\\n    uint256 constant Q128 = 2**128;\\n    uint256 constant Q96 = 2**96;\\n    uint256 constant Q48 = 2**48;\\n    uint256 constant Q160 = 2**160;\\n    uint256 constant UNI_FEE_DENOMINATOR = 10**6;\\n\\n    /// @notice Sort uint256 using bubble sort. The sorting is done in-place.\\n    /// @param arr Array of uint256\\n    function sortUint(uint256[] memory arr) internal pure {\\n        uint256 l = arr.length;\\n        for (uint256 i = 0; i < l; ++i) {\\n            for (uint256 j = i + 1; j < l; ++j) {\\n                if (arr[i] > arr[j]) {\\n                    uint256 temp = arr[i];\\n                    arr[i] = arr[j];\\n                    arr[j] = temp;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Checks if array of addresses is sorted and all adresses are unique\\n    /// @param tokens A set of addresses to check\\n    /// @return `true` if all addresses are sorted and unique, `false` otherwise\\n    function isSortedAndUnique(address[] memory tokens) internal pure returns (bool) {\\n        if (tokens.length < 2) {\\n            return true;\\n        }\\n        for (uint256 i = 0; i < tokens.length - 1; ++i) {\\n            if (tokens[i] >= tokens[i + 1]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /// @notice Projects tokenAmounts onto subset or superset of tokens\\n    /// @dev\\n    /// Requires both sets of tokens to be sorted. When tokens are not sorted, it's undefined behavior.\\n    /// If there is a token in tokensToProject that is not part of tokens and corresponding tokenAmountsToProject > 0, reverts.\\n    /// Zero token amount is eqiuvalent to missing token\\n    function projectTokenAmounts(\\n        address[] memory tokens,\\n        address[] memory tokensToProject,\\n        uint256[] memory tokenAmountsToProject\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory res = new uint256[](tokens.length);\\n        uint256 t = 0;\\n        uint256 tp = 0;\\n        while ((t < tokens.length) && (tp < tokensToProject.length)) {\\n            if (tokens[t] < tokensToProject[tp]) {\\n                res[t] = 0;\\n                t++;\\n            } else if (tokens[t] > tokensToProject[tp]) {\\n                if (tokenAmountsToProject[tp] == 0) {\\n                    tp++;\\n                } else {\\n                    revert(\\\"TPS\\\");\\n                }\\n            } else {\\n                res[t] = tokenAmountsToProject[tp];\\n                t++;\\n                tp++;\\n            }\\n        }\\n        while (t < tokens.length) {\\n            res[t] = 0;\\n            t++;\\n        }\\n        return res;\\n    }\\n\\n    /// @notice Calculated sqrt of uint in X96 format\\n    /// @param xX96 input number in X96 format\\n    /// @return sqrt of xX96 in X96 format\\n    function sqrtX96(uint256 xX96) internal pure returns (uint256) {\\n        uint256 sqX96 = sqrt(xX96);\\n        return sqX96 << 48;\\n    }\\n\\n    /// @notice Calculated sqrt of uint\\n    /// @param x input number\\n    /// @return sqrt of x\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        if (x == 0) return 0;\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) {\\n            xx >>= 128;\\n            r <<= 64;\\n        }\\n        if (xx >= 0x10000000000000000) {\\n            xx >>= 64;\\n            r <<= 32;\\n        }\\n        if (xx >= 0x100000000) {\\n            xx >>= 32;\\n            r <<= 16;\\n        }\\n        if (xx >= 0x10000) {\\n            xx >>= 16;\\n            r <<= 8;\\n        }\\n        if (xx >= 0x100) {\\n            xx >>= 8;\\n            r <<= 4;\\n        }\\n        if (xx >= 0x10) {\\n            xx >>= 4;\\n            r <<= 2;\\n        }\\n        if (xx >= 0x8) {\\n            r <<= 1;\\n        }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        uint256 r1 = x / r;\\n        return (r < r1 ? r : r1);\\n    }\\n\\n    /// @notice Recovers signer address from signed message hash\\n    /// @param _ethSignedMessageHash signed message\\n    /// @param _signature contatenated ECDSA r, s, v (65 bytes)\\n    /// @return Recovered address if the signature is valid, address(0) otherwise\\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    /// @notice Get ECDSA r, s, v from signature\\n    /// @param sig signature (65 bytes)\\n    /// @return r ECDSA r\\n    /// @return s ECDSA s\\n    /// @return v ECDSA v\\n    function splitSignature(bytes memory sig)\\n        internal\\n        pure\\n        returns (\\n            bytes32 r,\\n            bytes32 s,\\n            uint8 v\\n        )\\n    {\\n        require(sig.length == 65, ExceptionsLibrary.INVALID_LENGTH);\\n\\n        assembly {\\n            r := mload(add(sig, 32))\\n            s := mload(add(sig, 64))\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xef6a88b594b83a9be518e705b0b1fc513657fe940cec0d68749fc55e64d7eb97\",\"license\":\"MIT\"},\"contracts/libraries/ExceptionsLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/// @notice Exceptions stores project`s smart-contracts exceptions\\nlibrary ExceptionsLibrary {\\n    string constant ADDRESS_ZERO = \\\"AZ\\\";\\n    string constant VALUE_ZERO = \\\"VZ\\\";\\n    string constant EMPTY_LIST = \\\"EMPL\\\";\\n    string constant NOT_FOUND = \\\"NF\\\";\\n    string constant INIT = \\\"INIT\\\";\\n    string constant DUPLICATE = \\\"DUP\\\";\\n    string constant NULL = \\\"NULL\\\";\\n    string constant TIMESTAMP = \\\"TS\\\";\\n    string constant FORBIDDEN = \\\"FRB\\\";\\n    string constant ALLOWLIST = \\\"ALL\\\";\\n    string constant LIMIT_OVERFLOW = \\\"LIMO\\\";\\n    string constant LIMIT_UNDERFLOW = \\\"LIMU\\\";\\n    string constant INVALID_VALUE = \\\"INV\\\";\\n    string constant INVARIANT = \\\"INVA\\\";\\n    string constant INVALID_TARGET = \\\"INVTR\\\";\\n    string constant INVALID_TOKEN = \\\"INVTO\\\";\\n    string constant INVALID_INTERFACE = \\\"INVI\\\";\\n    string constant INVALID_SELECTOR = \\\"INVS\\\";\\n    string constant INVALID_STATE = \\\"INVST\\\";\\n    string constant INVALID_LENGTH = \\\"INVL\\\";\\n    string constant LOCK = \\\"LCKD\\\";\\n    string constant DISABLED = \\\"DIS\\\";\\n}\\n\",\"keccak256\":\"0xf17911249ff44eab954080bf27b20232f4d87d30e609aabc70046d644e35fbb5\",\"license\":\"MIT\"},\"contracts/libraries/external/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.9;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // diff: original lib works under 0.7.6 with overflows enabled\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            // diff: original uint256 twos = -denominator & denominator;\\n            uint256 twos = uint256(-int256(denominator)) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // diff: original lib works under 0.7.6 with overflows enabled\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4eba21427a2a12cd7174047367a625fe9e64946ecc2dd60682d14b97c10fb169\",\"license\":\"MIT\"},\"contracts/oracles/UniV2Oracle.sol\":{\"content\":\"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"../interfaces/external/univ2/IUniswapV2Pair.sol\\\";\\nimport \\\"../interfaces/external/univ2/IUniswapV2Factory.sol\\\";\\nimport \\\"../interfaces/oracles/IUniV2Oracle.sol\\\";\\nimport \\\"../libraries/CommonLibrary.sol\\\";\\nimport \\\"../utils/ContractMeta.sol\\\";\\n\\ncontract UniV2Oracle is ContractMeta, IUniV2Oracle, ERC165 {\\n    /// @inheritdoc IUniV2Oracle\\n    IUniswapV2Factory public immutable factory;\\n    /// @inheritdoc IUniV2Oracle\\n    uint8 public constant safetyIndex = 1;\\n\\n    constructor(IUniswapV2Factory factory_) {\\n        factory = factory_;\\n    }\\n\\n    // -------------------------  EXTERNAL, VIEW  ------------------------------\\n\\n    /// @inheritdoc IOracle\\n    function priceX96(\\n        address token0,\\n        address token1,\\n        uint256 safetyIndicesSet\\n    ) external view returns (uint256[] memory pricesX96, uint256[] memory safetyIndices) {\\n        bool isSwapped = false;\\n        if (token0 > token1) {\\n            (token0, token1) = (token1, token0);\\n            isSwapped = true;\\n        }\\n        if (((safetyIndicesSet >> safetyIndex) & 1) != 1) {\\n            return (pricesX96, safetyIndices);\\n        }\\n        IUniswapV2Pair pool = IUniswapV2Pair(factory.getPair(token0, token1));\\n        if (address(pool) == address(0)) {\\n            return (pricesX96, safetyIndices);\\n        }\\n        (uint112 reserve0, uint112 reserve1, ) = pool.getReserves();\\n        pricesX96 = new uint256[](1);\\n        safetyIndices = new uint256[](1);\\n        if (isSwapped) {\\n            pricesX96[0] = FullMath.mulDiv(reserve0, CommonLibrary.Q96, reserve1);\\n        } else {\\n            pricesX96[0] = FullMath.mulDiv(reserve1, CommonLibrary.Q96, reserve0);\\n        }\\n        safetyIndices[0] = safetyIndex;\\n    }\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return super.supportsInterface(interfaceId) || type(IUniV2Oracle).interfaceId == interfaceId;\\n    }\\n\\n    // -------------------  INTERNAL, VIEW  -------------------\\n\\n    function _contractName() internal pure override returns (bytes32) {\\n        return bytes32(\\\"UniV2Oracle\\\");\\n    }\\n\\n    function _contractVersion() internal pure override returns (bytes32) {\\n        return bytes32(\\\"1.0.0\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x50388c056a26effe965a5fe08d9998388d02e00a91327d272502b10ef378e5b5\",\"license\":\"BSL-1.1\"},\"contracts/utils/ContractMeta.sol\":{\"content\":\"// SPDX-License-Identifier: BSL-1.1\\npragma solidity 0.8.9;\\n\\nimport \\\"../interfaces/utils/IContractMeta.sol\\\";\\n\\nabstract contract ContractMeta is IContractMeta {\\n    // -------------------  EXTERNAL, VIEW  -------------------\\n\\n    function contractName() external pure returns (string memory) {\\n        return _bytes32ToString(_contractName());\\n    }\\n\\n    function contractNameBytes() external pure returns (bytes32) {\\n        return _contractName();\\n    }\\n\\n    function contractVersion() external pure returns (string memory) {\\n        return _bytes32ToString(_contractVersion());\\n    }\\n\\n    function contractVersionBytes() external pure returns (bytes32) {\\n        return _contractVersion();\\n    }\\n\\n    // -------------------  INTERNAL, VIEW  -------------------\\n\\n    function _contractName() internal pure virtual returns (bytes32);\\n\\n    function _contractVersion() internal pure virtual returns (bytes32);\\n\\n    function _bytes32ToString(bytes32 b) internal pure returns (string memory s) {\\n        s = new string(32);\\n        uint256 len = 32;\\n        for (uint256 i = 0; i < 32; ++i) {\\n            if (uint8(b[i]) == 0) {\\n                len = i;\\n                break;\\n            }\\n        }\\n        assembly {\\n            mstore(s, len)\\n            mstore(add(s, 0x20), b)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaed32a95ba32842eb484fcd8febba8bdc7b4a736605c208ec093efcfe1800c93\",\"license\":\"BSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161083d38038061083d83398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b6080516107ab61009260003960008181610124015261021601526107ab6000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c806375d0c0dc1161005b57806375d0c0dc14610102578063a0a8e46014610117578063c45a01551461011f578063e312650b1461015e57600080fd5b806301ffc9a71461008d57806306a46239146100b55780630e3e80ac146100cd5780636d80125b146100e1575b600080fd5b6100a061009b36600461056c565b610178565b60405190151581526020015b60405180910390f35b640312e302e360dc1b5b6040519081526020016100ac565b6a556e6956324f7261636c6560a81b6100bf565b6100f46100ef3660046105ae565b6101b4565b6040516100ac92919061062a565b61010a610420565b6040516100ac9190610658565b61010a610439565b6101467f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100ac565b610166600181565b60405160ff90911681526020016100ac565b60006301ffc9a760e01b6001600160e01b0319831614806101a957506313a4322f60e11b6001600160e01b03198316145b92915050565b905090565b6060806000846001600160a01b0316866001600160a01b031611156101da575092939260015b600184811c8116146101ec5750610418565b60405163e6a4390560e01b81526001600160a01b03878116600483015286811660248301526000917f00000000000000000000000000000000000000000000000000000000000000009091169063e6a439059060440160206040518083038186803b15801561025a57600080fd5b505afa15801561026e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061029291906106ad565b90506001600160a01b0381166102a9575050610418565b600080826001600160a01b0316630902f1ac6040518163ffffffff1660e01b815260040160606040518083038186803b1580156102e557600080fd5b505afa1580156102f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061031d91906106e6565b5060408051600180825281830190925292945090925060208083019080368337505060408051600180825281830190925292985090506020808301908036833701905050945083156103ae5761038a826001600160701b0316600160601b836001600160701b031661044c565b8660008151811061039d5761039d610736565b6020026020010181815250506103ef565b6103cf816001600160701b0316600160601b846001600160701b031661044c565b866000815181106103e2576103e2610736565b6020026020010181815250505b600160ff168560008151811061040757610407610736565b602002602001018181525050505050505b935093915050565b60606101af6a556e6956324f7261636c6560a81b610500565b60606101af640312e302e360dc1b610500565b600080806000198587098587029250828110838203039150508060001415610486576000841161047b57600080fd5b5082900490506104f9565b80841161049257600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150505b9392505050565b604080516020808252818301909252606091602082018180368337019050509050602060005b602081101561055e5783816020811061054157610541610736565b1a61054e5780915061055e565b6105578161074c565b9050610526565b508152602081019190915290565b60006020828403121561057e57600080fd5b81356001600160e01b0319811681146104f957600080fd5b6001600160a01b03811681146105ab57600080fd5b50565b6000806000606084860312156105c357600080fd5b83356105ce81610596565b925060208401356105de81610596565b929592945050506040919091013590565b600081518084526020808501945080840160005b8381101561061f57815187529582019590820190600101610603565b509495945050505050565b60408152600061063d60408301856105ef565b828103602084015261064f81856105ef565b95945050505050565b600060208083528351808285015260005b8181101561068557858101830151858201604001528201610669565b81811115610697576000604083870101525b50601f01601f1916929092016040019392505050565b6000602082840312156106bf57600080fd5b81516104f981610596565b80516001600160701b03811681146106e157600080fd5b919050565b6000806000606084860312156106fb57600080fd5b610704846106ca565b9250610712602085016106ca565b9150604084015163ffffffff8116811461072b57600080fd5b809150509250925092565b634e487b7160e01b600052603260045260246000fd5b600060001982141561076e57634e487b7160e01b600052601160045260246000fd5b506001019056fea26469706673582212209702ba196acdd04f16ddf43791d272e707cc8267530222f0f7e0eb529b3f191e64736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100885760003560e01c806375d0c0dc1161005b57806375d0c0dc14610102578063a0a8e46014610117578063c45a01551461011f578063e312650b1461015e57600080fd5b806301ffc9a71461008d57806306a46239146100b55780630e3e80ac146100cd5780636d80125b146100e1575b600080fd5b6100a061009b36600461056c565b610178565b60405190151581526020015b60405180910390f35b640312e302e360dc1b5b6040519081526020016100ac565b6a556e6956324f7261636c6560a81b6100bf565b6100f46100ef3660046105ae565b6101b4565b6040516100ac92919061062a565b61010a610420565b6040516100ac9190610658565b61010a610439565b6101467f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100ac565b610166600181565b60405160ff90911681526020016100ac565b60006301ffc9a760e01b6001600160e01b0319831614806101a957506313a4322f60e11b6001600160e01b03198316145b92915050565b905090565b6060806000846001600160a01b0316866001600160a01b031611156101da575092939260015b600184811c8116146101ec5750610418565b60405163e6a4390560e01b81526001600160a01b03878116600483015286811660248301526000917f00000000000000000000000000000000000000000000000000000000000000009091169063e6a439059060440160206040518083038186803b15801561025a57600080fd5b505afa15801561026e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061029291906106ad565b90506001600160a01b0381166102a9575050610418565b600080826001600160a01b0316630902f1ac6040518163ffffffff1660e01b815260040160606040518083038186803b1580156102e557600080fd5b505afa1580156102f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061031d91906106e6565b5060408051600180825281830190925292945090925060208083019080368337505060408051600180825281830190925292985090506020808301908036833701905050945083156103ae5761038a826001600160701b0316600160601b836001600160701b031661044c565b8660008151811061039d5761039d610736565b6020026020010181815250506103ef565b6103cf816001600160701b0316600160601b846001600160701b031661044c565b866000815181106103e2576103e2610736565b6020026020010181815250505b600160ff168560008151811061040757610407610736565b602002602001018181525050505050505b935093915050565b60606101af6a556e6956324f7261636c6560a81b610500565b60606101af640312e302e360dc1b610500565b600080806000198587098587029250828110838203039150508060001415610486576000841161047b57600080fd5b5082900490506104f9565b80841161049257600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150505b9392505050565b604080516020808252818301909252606091602082018180368337019050509050602060005b602081101561055e5783816020811061054157610541610736565b1a61054e5780915061055e565b6105578161074c565b9050610526565b508152602081019190915290565b60006020828403121561057e57600080fd5b81356001600160e01b0319811681146104f957600080fd5b6001600160a01b03811681146105ab57600080fd5b50565b6000806000606084860312156105c357600080fd5b83356105ce81610596565b925060208401356105de81610596565b929592945050506040919091013590565b600081518084526020808501945080840160005b8381101561061f57815187529582019590820190600101610603565b509495945050505050565b60408152600061063d60408301856105ef565b828103602084015261064f81856105ef565b95945050505050565b600060208083528351808285015260005b8181101561068557858101830151858201604001528201610669565b81811115610697576000604083870101525b50601f01601f1916929092016040019392505050565b6000602082840312156106bf57600080fd5b81516104f981610596565b80516001600160701b03811681146106e157600080fd5b919050565b6000806000606084860312156106fb57600080fd5b610704846106ca565b9250610712602085016106ca565b9150604084015163ffffffff8116811461072b57600080fd5b809150509250925092565b634e487b7160e01b600052603260045260246000fd5b600060001982141561076e57634e487b7160e01b600052601160045260246000fd5b506001019056fea26469706673582212209702ba196acdd04f16ddf43791d272e707cc8267530222f0f7e0eb529b3f191e64736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "priceX96(address,address,uint256)": {
        "details": "The price is token1 / token0 i.e. how many weis of token1 required for 1 wei of token0. The safety indexes are: 1 - unsafe, this is typically a spot price that can be easily manipulated, 2 - 4 - more or less safe, this is typically a uniV3 oracle, where the safety is defined by the timespan of the average price 5 - safe - this is typically a chailink oracle",
        "params": {
          "safetyIndicesSet": "Bitmask of safety indices that are allowed for the return prices. For set of safety indexes = { 1 }, safetyIndicesSet = 0x2",
          "token0": "Reference to token0",
          "token1": "Reference to token1"
        },
        "returns": {
          "pricesX96": "Prices that satisfy safetyIndex and tokens",
          "safetyIndices": "Safety indices for those prices"
        }
      },
      "supportsInterface(bytes4)": {
        "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "factory()": {
        "notice": "Reference to UniV2 factory"
      },
      "priceX96(address,address,uint256)": {
        "notice": "Oracle price for tokens as a Q64.96 value.Returns pricing information based on the indexes of non-zero bits in safetyIndicesSet.It is possible that not all indices will have their respective prices returned."
      },
      "safetyIndex()": {
        "notice": "Index of safety bit"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}