{
  "address": "0xACEE4A703f27eA1EbCd550511aAE58ad012624CC",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "tvls",
          "type": "uint256[]"
        },
        {
          "internalType": "address[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "contract IOracle",
          "name": "oracle",
          "type": "address"
        }
      ],
      "name": "getTvlToken0",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "tvl0",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x37d92e56073770ac22c1f5bdbedf3bc3e0a6e7454e4609e22e3d5404ade8e19c",
  "receipt": {
    "to": null,
    "from": "0xF13c450e913001Ac0647710D44d8eE9760009b4D",
    "contractAddress": "0xACEE4A703f27eA1EbCd550511aAE58ad012624CC",
    "transactionIndex": 30,
    "gasUsed": "396563",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x31636c04d482f06a08a795c6c2907f445f4ae3635c7807bd20f2fe21aa920481",
    "transactionHash": "0x37d92e56073770ac22c1f5bdbedf3bc3e0a6e7454e4609e22e3d5404ade8e19c",
    "logs": [],
    "blockNumber": 15237765,
    "cumulativeGasUsed": "4625379",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "1d49726b754ac7f6cccc3c78633d62a4",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tvls\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"getTvlToken0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tvl0\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/utils/ERC20RootVaultHelper.sol\":\"ERC20RootVaultHelper\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/oracles/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IOracle {\\n    /// @notice Oracle price for tokens as a Q64.96 value.\\n    /// @notice Returns pricing information based on the indexes of non-zero bits in safetyIndicesSet.\\n    /// @notice It is possible that not all indices will have their respective prices returned.\\n    /// @dev The price is token1 / token0 i.e. how many weis of token1 required for 1 wei of token0.\\n    /// The safety indexes are:\\n    ///\\n    /// 1 - unsafe, this is typically a spot price that can be easily manipulated,\\n    ///\\n    /// 2 - 4 - more or less safe, this is typically a uniV3 oracle, where the safety is defined by the timespan of the average price\\n    ///\\n    /// 5 - safe - this is typically a chailink oracle\\n    /// @param token0 Reference to token0\\n    /// @param token1 Reference to token1\\n    /// @param safetyIndicesSet Bitmask of safety indices that are allowed for the return prices. For set of safety indexes = { 1 }, safetyIndicesSet = 0x2\\n    /// @return pricesX96 Prices that satisfy safetyIndex and tokens\\n    /// @return safetyIndices Safety indices for those prices\\n    function priceX96(\\n        address token0,\\n        address token1,\\n        uint256 safetyIndicesSet\\n    ) external view returns (uint256[] memory pricesX96, uint256[] memory safetyIndices);\\n}\\n\",\"keccak256\":\"0x64a04c20495bc7e46040acb0df28c866cfd2d4fd8eced03bc3595d817619dc19\",\"license\":\"MIT\"},\"contracts/interfaces/utils/IERC20RootVaultHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"../oracles/IOracle.sol\\\";\\n\\ninterface IERC20RootVaultHelper {\\n    function getTvlToken0(\\n        uint256[] calldata tvls,\\n        address[] calldata tokens,\\n        IOracle oracle\\n    ) external view returns (uint256 tvl0);\\n}\\n\",\"keccak256\":\"0x83d7bc6139b7654637cb4c131756e04c1821196b02881b2889e69b77f0c2d607\",\"license\":\"MIT\"},\"contracts/libraries/CommonLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./external/FullMath.sol\\\";\\nimport \\\"./ExceptionsLibrary.sol\\\";\\n\\n/// @notice CommonLibrary shared utilities\\nlibrary CommonLibrary {\\n    uint256 constant DENOMINATOR = 10**9;\\n    uint256 constant D18 = 10**18;\\n    uint256 constant YEAR = 365 * 24 * 3600;\\n    uint256 constant Q128 = 2**128;\\n    uint256 constant Q96 = 2**96;\\n    uint256 constant Q48 = 2**48;\\n    uint256 constant Q160 = 2**160;\\n    uint256 constant UNI_FEE_DENOMINATOR = 10**6;\\n\\n    /// @notice Sort uint256 using bubble sort. The sorting is done in-place.\\n    /// @param arr Array of uint256\\n    function sortUint(uint256[] memory arr) internal pure {\\n        uint256 l = arr.length;\\n        for (uint256 i = 0; i < l; ++i) {\\n            for (uint256 j = i + 1; j < l; ++j) {\\n                if (arr[i] > arr[j]) {\\n                    uint256 temp = arr[i];\\n                    arr[i] = arr[j];\\n                    arr[j] = temp;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Checks if array of addresses is sorted and all adresses are unique\\n    /// @param tokens A set of addresses to check\\n    /// @return `true` if all addresses are sorted and unique, `false` otherwise\\n    function isSortedAndUnique(address[] memory tokens) internal pure returns (bool) {\\n        if (tokens.length < 2) {\\n            return true;\\n        }\\n        for (uint256 i = 0; i < tokens.length - 1; ++i) {\\n            if (tokens[i] >= tokens[i + 1]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /// @notice Projects tokenAmounts onto subset or superset of tokens\\n    /// @dev\\n    /// Requires both sets of tokens to be sorted. When tokens are not sorted, it's undefined behavior.\\n    /// If there is a token in tokensToProject that is not part of tokens and corresponding tokenAmountsToProject > 0, reverts.\\n    /// Zero token amount is eqiuvalent to missing token\\n    function projectTokenAmounts(\\n        address[] memory tokens,\\n        address[] memory tokensToProject,\\n        uint256[] memory tokenAmountsToProject\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory res = new uint256[](tokens.length);\\n        uint256 t = 0;\\n        uint256 tp = 0;\\n        while ((t < tokens.length) && (tp < tokensToProject.length)) {\\n            if (tokens[t] < tokensToProject[tp]) {\\n                res[t] = 0;\\n                t++;\\n            } else if (tokens[t] > tokensToProject[tp]) {\\n                if (tokenAmountsToProject[tp] == 0) {\\n                    tp++;\\n                } else {\\n                    revert(\\\"TPS\\\");\\n                }\\n            } else {\\n                res[t] = tokenAmountsToProject[tp];\\n                t++;\\n                tp++;\\n            }\\n        }\\n        while (t < tokens.length) {\\n            res[t] = 0;\\n            t++;\\n        }\\n        return res;\\n    }\\n\\n    /// @notice Calculated sqrt of uint in X96 format\\n    /// @param xX96 input number in X96 format\\n    /// @return sqrt of xX96 in X96 format\\n    function sqrtX96(uint256 xX96) internal pure returns (uint256) {\\n        uint256 sqX96 = sqrt(xX96);\\n        return sqX96 << 48;\\n    }\\n\\n    /// @notice Calculated sqrt of uint\\n    /// @param x input number\\n    /// @return sqrt of x\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        if (x == 0) return 0;\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) {\\n            xx >>= 128;\\n            r <<= 64;\\n        }\\n        if (xx >= 0x10000000000000000) {\\n            xx >>= 64;\\n            r <<= 32;\\n        }\\n        if (xx >= 0x100000000) {\\n            xx >>= 32;\\n            r <<= 16;\\n        }\\n        if (xx >= 0x10000) {\\n            xx >>= 16;\\n            r <<= 8;\\n        }\\n        if (xx >= 0x100) {\\n            xx >>= 8;\\n            r <<= 4;\\n        }\\n        if (xx >= 0x10) {\\n            xx >>= 4;\\n            r <<= 2;\\n        }\\n        if (xx >= 0x8) {\\n            r <<= 1;\\n        }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        uint256 r1 = x / r;\\n        return (r < r1 ? r : r1);\\n    }\\n\\n    /// @notice Recovers signer address from signed message hash\\n    /// @param _ethSignedMessageHash signed message\\n    /// @param _signature contatenated ECDSA r, s, v (65 bytes)\\n    /// @return Recovered address if the signature is valid, address(0) otherwise\\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    /// @notice Get ECDSA r, s, v from signature\\n    /// @param sig signature (65 bytes)\\n    /// @return r ECDSA r\\n    /// @return s ECDSA s\\n    /// @return v ECDSA v\\n    function splitSignature(bytes memory sig)\\n        internal\\n        pure\\n        returns (\\n            bytes32 r,\\n            bytes32 s,\\n            uint8 v\\n        )\\n    {\\n        require(sig.length == 65, ExceptionsLibrary.INVALID_LENGTH);\\n\\n        assembly {\\n            r := mload(add(sig, 32))\\n            s := mload(add(sig, 64))\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xef6a88b594b83a9be518e705b0b1fc513657fe940cec0d68749fc55e64d7eb97\",\"license\":\"MIT\"},\"contracts/libraries/ExceptionsLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/// @notice Exceptions stores project`s smart-contracts exceptions\\nlibrary ExceptionsLibrary {\\n    string constant ADDRESS_ZERO = \\\"AZ\\\";\\n    string constant VALUE_ZERO = \\\"VZ\\\";\\n    string constant EMPTY_LIST = \\\"EMPL\\\";\\n    string constant NOT_FOUND = \\\"NF\\\";\\n    string constant INIT = \\\"INIT\\\";\\n    string constant DUPLICATE = \\\"DUP\\\";\\n    string constant NULL = \\\"NULL\\\";\\n    string constant TIMESTAMP = \\\"TS\\\";\\n    string constant FORBIDDEN = \\\"FRB\\\";\\n    string constant ALLOWLIST = \\\"ALL\\\";\\n    string constant LIMIT_OVERFLOW = \\\"LIMO\\\";\\n    string constant LIMIT_UNDERFLOW = \\\"LIMU\\\";\\n    string constant INVALID_VALUE = \\\"INV\\\";\\n    string constant INVARIANT = \\\"INVA\\\";\\n    string constant INVALID_TARGET = \\\"INVTR\\\";\\n    string constant INVALID_TOKEN = \\\"INVTO\\\";\\n    string constant INVALID_INTERFACE = \\\"INVI\\\";\\n    string constant INVALID_SELECTOR = \\\"INVS\\\";\\n    string constant INVALID_STATE = \\\"INVST\\\";\\n    string constant INVALID_LENGTH = \\\"INVL\\\";\\n    string constant LOCK = \\\"LCKD\\\";\\n    string constant DISABLED = \\\"DIS\\\";\\n}\\n\",\"keccak256\":\"0xf17911249ff44eab954080bf27b20232f4d87d30e609aabc70046d644e35fbb5\",\"license\":\"MIT\"},\"contracts/libraries/external/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.9;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // diff: original lib works under 0.7.6 with overflows enabled\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            // diff: original uint256 twos = -denominator & denominator;\\n            uint256 twos = uint256(-int256(denominator)) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // diff: original lib works under 0.7.6 with overflows enabled\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4eba21427a2a12cd7174047367a625fe9e64946ecc2dd60682d14b97c10fb169\",\"license\":\"MIT\"},\"contracts/utils/ERC20RootVaultHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\nimport \\\"../libraries/ExceptionsLibrary.sol\\\";\\nimport \\\"../interfaces/utils/IERC20RootVaultHelper.sol\\\";\\nimport \\\"../libraries/CommonLibrary.sol\\\";\\nimport \\\"../libraries/external/FullMath.sol\\\";\\n\\ncontract ERC20RootVaultHelper is IERC20RootVaultHelper {\\n    function getTvlToken0(\\n        uint256[] calldata tvls,\\n        address[] calldata tokens,\\n        IOracle oracle\\n    ) external view returns (uint256 tvl0) {\\n        tvl0 = tvls[0];\\n        for (uint256 i = 1; i < tvls.length; i++) {\\n            (uint256[] memory pricesX96, ) = oracle.priceX96(tokens[0], tokens[i], 0x30);\\n            require(pricesX96.length > 0, ExceptionsLibrary.VALUE_ZERO);\\n            uint256 priceX96 = 0;\\n            for (uint256 j = 0; j < pricesX96.length; j++) {\\n                priceX96 += pricesX96[j];\\n            }\\n            priceX96 /= pricesX96.length;\\n            tvl0 += FullMath.mulDiv(tvls[i], CommonLibrary.Q96, priceX96);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa80809cf8847999888000479f74a12222a222d316f26107ca186961f7b9089dc\",\"license\":\"GPL-2.0-or-later\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610637806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80634bd8911414610030575b600080fd5b61004361003e366004610375565b610055565b60405190815260200160405180910390f35b60008585600081811061006a5761006a6103f9565b9050602002013590506000600190505b85811015610253576000836001600160a01b0316636d80125b878760008181106100a6576100a66103f9565b90506020020160208101906100bb919061040f565b8888868181106100cd576100cd6103f9565b90506020020160208101906100e2919061040f565b6040516001600160e01b031960e085901b1681526001600160a01b039283166004820152911660248201526030604482015260640160006040518083038186803b15801561012f57600080fd5b505afa158015610143573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261016b91908101906104dd565b5090506000815111604051806040016040528060028152602001612b2d60f11b815250906101b55760405162461bcd60e51b81526004016101ac9190610541565b60405180910390fd5b506000805b82518110156101fc578281815181106101d5576101d56103f9565b6020026020010151826101e891906105ac565b9150806101f4816105c4565b9150506101ba565b50815161020990826105df565b9050610232898985818110610220576102206103f9565b90506020020135600160601b8361025d565b61023c90856105ac565b93505050808061024b906105c4565b91505061007a565b5095945050505050565b600080806000198587098587029250828110838203039150508060001415610297576000841161028c57600080fd5b50829004905061030a565b8084116102a357600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150505b9392505050565b60008083601f84011261032357600080fd5b50813567ffffffffffffffff81111561033b57600080fd5b6020830191508360208260051b850101111561035657600080fd5b9250929050565b6001600160a01b038116811461037257600080fd5b50565b60008060008060006060868803121561038d57600080fd5b853567ffffffffffffffff808211156103a557600080fd5b6103b189838a01610311565b909750955060208801359150808211156103ca57600080fd5b506103d788828901610311565b90945092505060408601356103eb8161035d565b809150509295509295909350565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561042157600080fd5b813561030a8161035d565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261045357600080fd5b8151602067ffffffffffffffff808311156104705761047061042c565b8260051b604051601f19603f830116810181811084821117156104955761049561042c565b6040529384528581018301938381019250878511156104b357600080fd5b83870191505b848210156104d2578151835291830191908301906104b9565b979650505050505050565b600080604083850312156104f057600080fd5b825167ffffffffffffffff8082111561050857600080fd5b61051486838701610442565b9350602085015191508082111561052a57600080fd5b5061053785828601610442565b9150509250929050565b600060208083528351808285015260005b8181101561056e57858101830151858201604001528201610552565b81811115610580576000604083870101525b50601f01601f1916929092016040019392505050565b634e487b7160e01b600052601160045260246000fd5b600082198211156105bf576105bf610596565b500190565b60006000198214156105d8576105d8610596565b5060010190565b6000826105fc57634e487b7160e01b600052601260045260246000fd5b50049056fea264697066735822122027b7e6819b0a498a63b2f96254ac41fbbdbaa0e0810a91a6cf6643c5c178d0eb64736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80634bd8911414610030575b600080fd5b61004361003e366004610375565b610055565b60405190815260200160405180910390f35b60008585600081811061006a5761006a6103f9565b9050602002013590506000600190505b85811015610253576000836001600160a01b0316636d80125b878760008181106100a6576100a66103f9565b90506020020160208101906100bb919061040f565b8888868181106100cd576100cd6103f9565b90506020020160208101906100e2919061040f565b6040516001600160e01b031960e085901b1681526001600160a01b039283166004820152911660248201526030604482015260640160006040518083038186803b15801561012f57600080fd5b505afa158015610143573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261016b91908101906104dd565b5090506000815111604051806040016040528060028152602001612b2d60f11b815250906101b55760405162461bcd60e51b81526004016101ac9190610541565b60405180910390fd5b506000805b82518110156101fc578281815181106101d5576101d56103f9565b6020026020010151826101e891906105ac565b9150806101f4816105c4565b9150506101ba565b50815161020990826105df565b9050610232898985818110610220576102206103f9565b90506020020135600160601b8361025d565b61023c90856105ac565b93505050808061024b906105c4565b91505061007a565b5095945050505050565b600080806000198587098587029250828110838203039150508060001415610297576000841161028c57600080fd5b50829004905061030a565b8084116102a357600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150505b9392505050565b60008083601f84011261032357600080fd5b50813567ffffffffffffffff81111561033b57600080fd5b6020830191508360208260051b850101111561035657600080fd5b9250929050565b6001600160a01b038116811461037257600080fd5b50565b60008060008060006060868803121561038d57600080fd5b853567ffffffffffffffff808211156103a557600080fd5b6103b189838a01610311565b909750955060208801359150808211156103ca57600080fd5b506103d788828901610311565b90945092505060408601356103eb8161035d565b809150509295509295909350565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561042157600080fd5b813561030a8161035d565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261045357600080fd5b8151602067ffffffffffffffff808311156104705761047061042c565b8260051b604051601f19603f830116810181811084821117156104955761049561042c565b6040529384528581018301938381019250878511156104b357600080fd5b83870191505b848210156104d2578151835291830191908301906104b9565b979650505050505050565b600080604083850312156104f057600080fd5b825167ffffffffffffffff8082111561050857600080fd5b61051486838701610442565b9350602085015191508082111561052a57600080fd5b5061053785828601610442565b9150509250929050565b600060208083528351808285015260005b8181101561056e57858101830151858201604001528201610552565b81811115610580576000604083870101525b50601f01601f1916929092016040019392505050565b634e487b7160e01b600052601160045260246000fd5b600082198211156105bf576105bf610596565b500190565b60006000198214156105d8576105d8610596565b5060010190565b6000826105fc57634e487b7160e01b600052601260045260246000fd5b50049056fea264697066735822122027b7e6819b0a498a63b2f96254ac41fbbdbaa0e0810a91a6cf6643c5c178d0eb64736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}